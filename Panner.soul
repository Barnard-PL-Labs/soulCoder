graph Panner [[main]]
{
    input stream float in1; // Left in
    input stream float in2; // Right in


    output stream float out1; // Left out
    output stream float out2; // Right out
    
    input
    {
        // user parameter, it's called endpoint annotaion
        // https://soul-lang.github.io/SOUL/docs/SOUL_Language.html#endpoint-annotations
        mixer.mix  [[ name:"pan", min: 0, max: 100, init: 0, unit: "%", step: 0.1 ]]; 
    }

    let 
    {
        //Mixer processor instance
        mixer = Mixer;
    } 
    
    connection
    {
        in1 -> mixer.in1;
        in2 -> mixer.in2;

        mixer.out1 -> out1;
        mixer.out2 -> out2;
    }
}

// Mixer processor take two input and mix them by the parameter value
processor Mixer()
{
    input stream float in1, in2;
    input stream float mix;

    output stream float out1, out2;
    
    void run()
    {
        loop
        {
            let in2_gain = soul::dBtoGain( 10 * log(mix/100.0f) ); //percent -> dB -> gain
            let in1_gain = 1.0f - in2_gain;

            out1 << (in1 * in1_gain);
            out2 << (in2 * in2_gain);

            advance();
        }
    }
}


// referenced from SOUL/example/Resonator.soul
// unused in Panner but I think it will likely be used later
processor Values (float[] vals)
{
    output event float out[vals.size];

    void run()
    {
        for (wrap<vals.size> i){
            out[i] << vals[i];
        }

        advance();
    }
}


processor FreqAnalysis ()
{

    input stream float instream;
    output value frequencyBands bands;

    struct frequencyBands
    {
        int b1;
        int b2;
        int b3;
        int b4;
        int b5;
        
        float g1;
        float g2;
        float g3;
        float g4;
        float g5;
    }

    frequencyBands fb;

    int BAND1_LOWER = 0;
    int BAND1_UPPER = 800;

    int BAND2_LOWER = 600;
    int BAND2_UPPER = 2140;

    int BAND3_LOWER = 2250;
    int BAND3_UPPER = 2900;

    int BAND4_LOWER = 2450;
    int BAND4_UPPER = 3900;

    int BAND5_LOWER = 2900;
    int BAND5_UPPER = 4950;






    const int NUM_DFT_SAMPLES = 44100;

    float[NUM_DFT_SAMPLES] inputReal;
    float[NUM_DFT_SAMPLES] inputImag;
    float[NUM_DFT_SAMPLES] outputReal;
    float[NUM_DFT_SAMPLES] outputImag;
    
    float[NUM_DFT_SAMPLES] magnitudes;

    wrap<NUM_DFT_SAMPLES> idx = 0;

    void init() {
        idx = 0;
    }


    void run() {

        loop
        {
            inputReal[idx] = instream;
            idx += 1;
            
            if (idx == NUM_DFT_SAMPLES) {
                
                //Do the DFT, results will be in outputReal, outputImag

                soul::DFT::performComplex(inputReal, 
                                          inputImag,
                                          outputReal,
                                          outputImag,
                                          1.0f / float (NUM_DFT_SAMPLES));

                //Compute the magnitudes

                float re;
                float im;
                for (int i = 0; i < NUM_DFT_SAMPLES; ++i) {
                    re = pow(outputReal[i], 2.0f);
                    im = pow(outputImag[i], 2.0f);

                    magnitudes[i] = pow(re+im, 0.5f);
                }


                //Find the highest frequency in each band

                int curMaxFreq = BAND1_LOWER;
                float curMaxGain = magnitudes[BAND1_LOWER];
                
                for (int freq = BAND1_LOWER; freq < BAND1_UPPER; ++freq) {
                    
                    if(magnitudes[freq] > curMaxGain) {
                        curMaxFreq = freq;
                        curMaxGain = magnitudes[freq];
                    }

                }

                fb.b1 = curMaxFreq;
                fb.g1 = curMaxGain;

                curMaxFreq = BAND2_LOWER;
                curMaxGain = magnitudes[BAND2_LOWER];
                
                for (int freq = BAND2_LOWER; freq < BAND2_UPPER; ++freq) {
                    
                    if(magnitudes[freq] > curMaxGain) {
                        curMaxFreq = freq;
                        curMaxGain = magnitudes[freq];
                    }

                }

                fb.b2 = curMaxFreq;
                fb.g2 = curMaxGain;


                curMaxFreq = BAND3_LOWER;
                curMaxGain = magnitudes[BAND3_LOWER];
                
                for (int freq = BAND3_LOWER; freq < BAND3_UPPER; ++freq) {
                    
                    if(magnitudes[freq] > curMaxGain) {
                        curMaxFreq = freq;
                        curMaxGain = magnitudes[freq];
                    }

                }

                fb.b3 = curMaxFreq;
                fb.g3 = curMaxGain;


                curMaxFreq = BAND4_LOWER;
                curMaxGain = magnitudes[BAND4_LOWER];
                
                for (int freq = BAND4_LOWER; freq < BAND4_UPPER; ++freq) {
                    
                    if(magnitudes[freq] > curMaxGain) {
                        curMaxFreq = freq;
                        curMaxGain = magnitudes[freq];
                    }

                }

                fb.b4 = curMaxFreq;
                fb.g4 = curMaxGain;


                curMaxFreq = BAND5_LOWER;
                curMaxGain = magnitudes[BAND5_LOWER];
                
                for (int freq = BAND5_LOWER; freq < BAND5_UPPER; ++freq) {
                    
                    if(magnitudes[freq] > curMaxGain) {
                        curMaxFreq = freq;
                        curMaxGain = magnitudes[freq];
                    }

                }

                fb.b5 = curMaxFreq;
                fb.g5 = curMaxGain;

                bands << fb;
            }



            advance();
        }
    }

}
