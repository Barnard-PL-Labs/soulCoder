graph TopLevel [[main]]
{
    input stream float32 in;
    output stream float32 out;
    input event
    {
        float rateHzIn   [[ min: 0.1,  max: 100,  init:  10,  name: "LFO Rate",  unit: "hz",  step: 0.1 ]];
        float depthIn    [[ min: 1,    max: 100,  init:  15,  name: "Mod Depth", unit: "ms",  step: 1 ]];
        float rateTempoIn  [[ name: "Rate (Tempo)", min: 0, max: 14, init: 0, text: "1/64|1/32|1/16T|1/16|1/16D|1/8T|1/8|1/8D|1/4|1/4D|1/2|1/1|2/1|4/1|8/1"]];
    }
    input osc.shapeIn;
    input osc.positionIn;
    input osc.transportStateIn;
    input osc.rateModeIn;
    input osc.syncIn;
    input osc.polarityIn;

    let delay = Delay(100000);
    namespace LFO = soul::oscillators::lfo;
    let osc = LFO::Processor (LFO::Shape::triangle, LFO::Polarity::unipolar, 1., 10.);
    let tempoRateMapper = TempoRateMapper;

    connection
    {
        rateHzIn -> osc.rateHzIn;
        depthIn -> osc.depthIn;
        osc.out -> delay.oscValue;
        rateTempoIn  -> tempoRateMapper.rateTempoIn;
        tempoRateMapper.out  -> osc.rateTempoIn;
        in -> delay.in;
        delay.out->out;
    }
}

processor Delay (const int maxDelayLength)
{
    input  stream float32 in;
    output stream float32 out;
    input  stream float oscValue;

    float[maxDelayLength] buffer;
    wrap<maxDelayLength> readPos, writePos;

    void run()
    {
        loop
        {
            let delaySamples = int (processor.frequency * (oscValue * 25) / 1000.0f);
            readPos = wrap<maxDelayLength> (writePos - delaySamples);
            buffer[writePos] = in;
            out << (buffer[readPos]);

            ++readPos;
            ++writePos;

            advance();
        }
    }
   
}

processor TempoRateMapper
{
    input event float32 rateTempoIn;
    output event float32 out;

    event rateTempoIn (float v)
    {
        let div = int(floor(v));
        var qnScalar = 0.f;

        if      (div == 0)  qnScalar = (64.0   / 4.0); // 1 sixty-fourth of a beat
        else if (div == 1)  qnScalar = (32.0   / 4.0); // 1 thirty-second of a beat
        else if (div == 2)  qnScalar = (24.0   / 4.0); // 1 sixteenth note triplet
        else if (div == 3)  qnScalar = (16.0   / 4.0); // 1 sixteenth note
        else if (div == 4)  qnScalar = (12.0   / 4.0); // 1 dotted sixteenth note
        else if (div == 5)  qnScalar = (9.0    / 4.0); // 1 eighth note triplet
        else if (div == 6)  qnScalar = (8.0    / 4.0); // 1 eighth note
        else if (div == 7)  qnScalar = (6.0    / 4.0); // 1 dotted eighth note
        else if (div == 8)  qnScalar = (4.0    / 4.0); // 1 quater note / 1 beat @ 4/4
        else if (div == 9)  qnScalar = (3.0    / 4.0); // 1 dotted quater note @ 4/4
        else if (div == 10) qnScalar = (2.0    / 4.0); // 2 beats @ 4/4
        else if (div == 11) qnScalar = (1.0    / 4.0); // 1 bar @ 4/4
        else if (div == 12) qnScalar = (0.5    / 4.0); // 2 bars @ 4/4
        else if (div == 13) qnScalar = (0.25   / 4.0); // 4 bars @ 4/4
        else if (div == 14) qnScalar = (0.125  / 4.0); // 8 bars @ 4/4

        out << qnScalar;
    }
}
