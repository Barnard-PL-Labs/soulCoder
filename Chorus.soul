graph TopLevel [[main]]
{
    input stream
    {
        float audioInL;
        float audioInR;
    }
    output stream
    {
        float audioOutL;
        float audioOutR;
    }

    input event
    {
        float rateHzIn   [[ min: 0.1,  max: 20,  init:  10,  name: "LFO Rate",  unit: "hz",  step: 0.1 ]];
        float depthIn    [[ min: 1,    max: 30,  init:  15,  name: "Mod Depth", unit: "ms",  step: 1 ]];
        float stereoOn   [[ min: 0,    max: 1,   init:  0,   name: "Stereo Off/On", text: "Off|On"]];
    }

    let delay = Delay(100000, 30);
    let lfo = soul::oscillators::lfo::Processor (0, 1, 15.0f, 10.0f);

    connection
    {
        rateHzIn -> lfo.rateHzIn;
        depthIn -> lfo.depthIn;
        stereoOn -> delay.stereoOn;
        lfo.out -> delay.lfoValue;
        audioInL -> delay.audioInL;
        audioInR -> delay.audioInR;
        delay.audioOutL -> audioOutL;
        delay.audioOutR -> audioOutR;
    }
}

processor Delay (const int maxDelayLength, const int delayCenter)
{
    input stream
    {
        float audioInL;
        float audioInR;
        float lfoValue;
    }

    output stream
    {
        float audioOutL;
        float audioOutR;
    }

    input event float stereoOn;

    event stereoOn(float on)
    {
        if (on == 1)
        {
            stereo = true;
        }
        else
        {
            stereo = false;
        }
    }

    float[maxDelayLength] bufferL, bufferR;
    wrap<maxDelayLength> readPosL, readPosR, writePos;
    int delaySamplesL, delaySamplesR;
    bool stereo;

    void run()
    {
        loop
        {
            delaySamplesL = max (1, int (processor.frequency * ((delayCenter + (lfoValue * 100)) / 1000.0f)));
            readPosL = wrap<maxDelayLength> (writePos - delaySamplesL);
            if (stereo)
            {
                delaySamplesR = max (1, int (processor.frequency * ((delayCenter + ((-1*lfoValue) * 100)) / 1000.0f)));
                readPosR = wrap<maxDelayLength> (writePos - delaySamplesR);
            }
            else
            {
                delaySamplesR = delaySamplesL;
                readPosR = readPosL;
            }


            bufferL[writePos] = audioInL;
            audioOutL << (bufferL[readPosL] + audioInL) / 2;
            ++readPosL;

            bufferR[writePos] = audioInR;
            audioOutR << (bufferR[readPosR] + audioInR) / 2;
            ++readPosR;

            ++writePos;

            advance();
        }
    }
}
